<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>270C_Support: SCC Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">270C_Support
   &#160;<span id="projectnumber">19/03/28</span>
   </div>
   <div id="projectbrief">Supporting C++ Classes For Math 270</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">SCC Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_double_vector1d.html">DoubleVector1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_double_vector1d_skin.html">DoubleVector1dSkin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_double_vector2d_skin.html">DoubleVector2dSkin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_double_vector3d_skin.html">DoubleVector3dSkin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_f_f_t___nvalues.html">FFT_Nvalues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__1d.html">fftw3_1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__2d.html">fftw3_2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__3d.html">fftw3_3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__cos1d.html">fftw3_cos1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__sin1d.html">fftw3_sin1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__sin2d.html">fftw3_sin2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1fftw3__sin3d.html">fftw3_sin3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function1d_skin.html">GridFunction1dSkin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function1d_utility.html">GridFunction1dUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function2d_skin.html">GridFunction2dSkin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function2d_slice_op.html">GridFunction2dSliceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function2d_utility.html">GridFunction2dUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function3d_skin.html">GridFunction3dSkin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function3d_slice_op.html">GridFunction3dSliceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_grid_function3d_utility.html">GridFunction3dUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_index_map1d.html">IndexMap1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_index_map2d.html">IndexMap2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_op1d.html">RandOp1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_op2d.html">RandOp2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_op3d.html">RandOp3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_op_dirichlet1d.html">RandOpDirichlet1d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_op_dirichlet2d.html">RandOpDirichlet2d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_op_dirichlet3d.html">RandOpDirichlet3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_rand_vector_op.html">RandVectorOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix representation of finite dimensional linear operators.  <a href="class_s_c_c_1_1_sparse_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides forward and inverse transforms of two dimensional data stored in <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instances or data stored in <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a> instances. Normalization and scaling is performed so that the transforms computed are close analogs to the mathematical transforms of periodic functions defined over intervals of size LX x LY.</p>
<p>The transforms are implemented using the dft_2d(...) routines from the FFTW3 Fast Fourier Transform library (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). The FFTW3 headers and library files must be available to create any executable that uses this class.</p>
<p>This transform interface is designed be used with the data values of discrete periodic functions associated with a uniform grid discretization consisting of nx grid panels x ny grid panels spanning a rectangular domain of size LX x LY.</p>
<p>When <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a>'s are used for input and/or output their size is nx x ny; the number of independent data values associated with the representation of periodic functions of such discretizations.</p>
<p>For computational efficiency nx and ny should be chosen to be a product of small primes less than or equal to 13 (if possible). </p><hr/>
<p>What's computed assuming the input data is specified as a <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instance initialized with the parameters (nx, xMin, xMax, ny, yMin, yMax):</p>
<p>If (kx,ky) is a wave number vector with kx, and ky in the ranges</p>
<p>-(nx/2) &lt;= kx &lt;= (nx-1)/2 and -(ny/2) &lt;= ky &lt;= (ny-1)/2</p>
<p>(the range calculated with integer division), then two <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instances whose values are the real and imaginary parts of</p>
<p>d = sqrt(1/LX)*exp(2*pi*I*kx*(x-xMin)/LX) sqrt(1/LY)*exp(2*pi*I*ky*(y-yMin)/LY)</p>
<p>evaluated the points</p>
<p>x = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny</p>
<p>get mapped by the forward transform to the two <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a> instances of size nx x ny, fhat_real and fhat_imag, where</p>
<p>fhat_real(kx + (nx/2), ky + (ny/2)) = 1 fhat_imag(kx + (nx/2), ky + (ny/2)) = 1</p>
<p>and all other values are zero.</p>
<p>Similarly the inverse transform maps the <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a> instances fhat_real and fhat_imag that have zero value except for a value of 1 in the (kx + (nx/2), ky + (ny/2)) entry to two <a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a> instances whose values consist of the real and imaginary components of</p>
<p>d = sqrt(1/LX)*exp(2*pi*I*kx*(x-xMin)/LX) sqrt(1/LY)*exp(2*pi*I*ky*(y-yMin)/LY)</p>
<p>evaluated the points</p>
<p>x = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny</p>
<p>After computing the transform of the data, one often wants to work with the discrete Fourier coefficients. Typically this is done by looping over the wave numbers, and then obtaining the coefficient by computing the correct offset. For example, one uses code constructs as indicated by the fragment below.</p>
<p>Loop over wave numbers</p>
<pre class="fragment">long kxIndex; long kyIndex;

for(kx = -(nx/2); kx &lt;= (nx-1)/2; kx++)
{
for(ky = -(ny/2); ky &lt;= (ny-1)/2; ky++)
{
kxIndex = kx + (nx/2);             // (kxIndex, kyIndex) = index of the transform
kyIndex = ky + (ny/2);             //  coefficient for the (kx,ky)'th  mode.

rk = realCoeff(kxIndex,kyIndex);   // real coefficient of the (kx,ky)'th mode
ik = imagCoeff(kxIndex,kyIndex);   // imag coefficient of the (kx,ky)'th mode




}}</pre><p>This class provides forward and inverse transforms of three dimensional data stored in <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instances or data stored in <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a> instances. Normalization and scaling is performed so that the transforms computed are close analogs to the mathematical transforms of periodic functions defined over intervals of size LX x LY x LZ.</p>
<p>The transforms are implemented using the dft_3d(...) routines from the FFTW3 Fast Fourier Transform library (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). The FFTW3 headers and library files must be available to create any executable that uses this class.</p>
<p>This transform interface is designed be used with the data values of discrete periodic functions associated with a uniform grid discretization consisting of nx grid panels by ny grid panels by nz grid panels spanning a rectangular domain of size LX x LY x LZ.</p>
<p>When <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a>'s are used for input and/or output their size is nx x ny x nz; the number of independent data values associated with the representation of periodic functions of such discretizations.</p>
<p>For computational efficiency nx, ny and nz should be chosen to be a product of small primes less than or equal to 13 (if possible). </p><hr/>
<p>What's computed assuming the input data is specified as a <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instance initialized with the parameters (nx, xMin, xMax, ny, yMin, yMax, nz, zMin, zMax):</p>
<p>If (kx,ky,kz) is a wave number vector with kx,ky and kz in the ranges</p>
<p>-(nx/2) &lt;= kx &lt;= (nx-1)/2 -(ny/2) &lt;= ky &lt;= (ny-1)/2, -(nz/2) &lt;= kz &lt;= (nz-1)/2</p>
<p>(the range calculated with integer division), then two <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instances whose values are the real and imaginary parts of</p>
<p>d = sqrt(1/LX)*exp(2*pi*I*kx*(x-xMin)/LX) sqrt(1/LY)*exp(2*pi*I*ky*(y-yMin)/LY) sqrt(1/LZ)*exp(2*pi*I*kz*(z-zMin)/LZ)</p>
<p>evaluated the points</p>
<p>x = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny z = zMin + k*hz, j = 0,1,...,nz-1, hz = LZ/nz</p>
<p>get mapped by the forward transform to the two <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a> instances of size nx x ny x nz, fhat_real and fhat_imag, where</p>
<p>fhat_real(kx + (nx/2), ky + (ny/2),kz + (nz/2)) = 1</p>
<p>and all other values of fhat_real and fhat_imag are zero.</p>
<p>Similarly the inverse transform maps <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a> instances fhat_real and fhat_imag that are zero except for a value 1 in the position (kx + (nx/2), ky + (ny/2),kz + (nz/2)) to two <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instances whose values consist of the real and imaginary components of</p>
<p>d = sqrt(1/LX)*exp(2*pi*I*kx*(x-xMin)/LX) sqrt(1/LY)*exp(2*pi*I*ky*(y-yMin)/LY) sqrt(1/LZ)*exp(2*pi*I*kz*(z-zMin)/LZ)</p>
<p>evaluated at the points</p>
<p>x = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny z = zMin + k*hz, j = 0,1,...,nz-1, hz = LZ/nz</p>
<pre class="fragment">After computing the transform of the data, one often wants to
work with the discrete Fourier coefficients. Typically this is done by
looping over the wave numbers, and then obtaining the coefficient by
computing the correct offset. For example, one uses code constructs
as indicated by the fragment below.
</pre><p>Loop over wave numbers</p>
<pre class="fragment">long kxIndex; long kyIndex; long kzIndex;

for(kx = -(nx/2); kx &lt;= (nx-1)/2; kx++)
{
for(ky = -(ny/2); ky &lt;= (ny-1)/2; ky++)
{
for(kz = -(nz/2); kz &lt;= (nz-1)/2; kz++)
{
kxIndex = kx + (nx/2);             // (kxIndex, kyIndex,kzIndex) = index of the transform
kyIndex = ky + (ny/2);             //  coefficient for the (kx,ky,kz) mode.
kzIndex = kz + (nz/2);             //

rk = realCoeff(kxIndex,kyIndex,kzIndex);   //  real coefficient of the (kx,ky,kz) mode
ik = imagCoeff(kxIndex,kyIndex,kzIndex);   //  imag coefficient of the (kx,ky,kz) mode




}}}</pre><p>This class provides forward and inverse cos transforms of one dimensional data stored in <a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a> instances or data stored in <a class="el" href="class_s_c_c_1_1_double_vector1d.html">DoubleVector1d</a> instances. Normalization and scaling is performed so that the transforms computed are close analogs to the mathematical sin transforms of functions defined over intervals of size LX.</p>
<p>The transforms are implemented using the r2r_1d(...) routine from the FFTW3 Fast Fourier Transform library (<a href="http://www.fftw.org/">http://www.fftw.org/</a>) with the transform parameter FFTW_REDFT00. The FFTW3 headers and library files must be available to create any executable that uses this class.</p>
<p>This transform interface is designed be used with the data values of discrete functions whose values are associated with a uniform grid discretization consisting of nx grid panels spanning a domain of size LX.</p>
<p>When <a class="el" href="class_s_c_c_1_1_double_vector1d.html">DoubleVector1d</a>'s are used for input and/or output their size is (nx+1); the number of data values associated with such discretizations.</p>
<p>For consistency with other FFTW_InterfaceNd classes, in the construction or initialization of class instances, the number of panels nx of a discretization is specified.</p>
<p>For computational efficiency nx should be chosen to be a product of small primes (if possible).</p>
<pre class="fragment">What's computed assuming the input data is specified as a
GridFunction1d instance initialized with the parameters
(nx, xMin, xMax):

===============================================================

If k is a wave number then GridFunction1d instance with values given by

d_i  = sqrt(2.0/LX)*cos(k*pi*(x_i-xMin))/LX)   (when k is in the range 1 &lt;= k &lt;= nx-1)

d_i  = sqrt(1.0/LX)*cos(k*pi*(x_i-xMin))/LX)   (when k = 0  and k = nx)

where x_i = xMin + i*hx where i =  0,...,nx and hx = LX/nx

gets mapped by the forward cosine transform to DoubleVector1d instance of
size (nx+1), f_hat, with 

fhat = (0,0,...,1,..,0)

where the non-zero value entry occurs in the kth position.

The inverse transform maps the DoubleVector1d instance with

f_hat = (0,0, ...,1,0,...,0)

with a value of 1 in the kth location 1 &lt;= k &lt;= nx-1 to  
containing the values

d  = sqrt(2.0/LX)*cos(k*pi*(x-xMin))/LX)

evaluated at the points x = xMin + i*hx where i =  0,...,nx and hx = LX/nx.

When fhat has a value of 1 in the 0th or nx'th position it is mapped
to a GridFunction1d instance containing the values

d  = sqrt(1.0/LX)*cos(k*pi*(x_i-xMin))/LX)  with x = i/nx and i = 0,...,nx

evaluated at the point x = xMin + i*hx where i =  0,...,nx and hx = LX/nx.

After computing the transform of the data, one often wants to
work with the discrete Fourier coefficients. Typically this is done by
looping over the wave numbers, and then obtaining the coefficient by
computing the correct offset. For example, one uses code constructs
as indicated by the fragment below.
</pre><p>Loop over cos wave numbers</p>
<pre class="fragment">for(long kx = 0; kx &lt;= nx; kx++)
{
    sCoeff  = f_hat(kx);  // (kx)'th cos coefficient is
                          // the (kx)'th entry of the transform


}</pre><p>This class provides forward and inverse sin transforms of one dimensional data stored in <a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a> instances or data stored in <a class="el" href="class_s_c_c_1_1_double_vector1d.html">DoubleVector1d</a> instances. Normalization and scaling is performed so that the transforms computed are close analogs to the mathematical sin transforms of functions defined over intervals of size LX.</p>
<p>The transforms are implemented using the r2r_1d(...) routine from the FFTW3 Fast Fourier Transform library (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). The FFTW3 headers and library files must be available to create any executable that uses this class.</p>
<p>This transform interface is designed be used with the data values of discrete functions with homogeneous boundary values associated with a uniform grid discretization consisting of nx grid panels spanning a domain of size LX.</p>
<p>When <a class="el" href="class_s_c_c_1_1_double_vector1d.html">DoubleVector1d</a>'s are used for input and/or output their size is (nx-1); the number of interior data values associated with such discretizations.</p>
<p>For consistency with other FFTW_InterfaceNd classes, in the construction or initialization of class instances, the number of panels nx of a discretization is specified.</p>
<p>For computational efficiency nx should be chosen to be a product of small primes (if possible).</p>
<p>What's computed assuming the input data is specified as a <a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a> instance initialized with the parameters (nx, xMin, xMax):</p>
<p>If kx is a wave number 1 &lt;= kx &lt;= nx-1</p>
<p>then <a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a> instances with values s(i) defined by</p>
<p>s(i) = sqrt(2/LX)*sin(kx*pi*(x_i-xMin)/LX)</p>
<p>with x_i = xMin + i/nx and i = 0,1,...,nx</p>
<p>are mapped by the forward transform to a DoubleVection1d instance of size (nx-1), f_hat, with a single non-zero entry</p>
<p>f_hat(kx-1) = 1.0</p>
<p>All other values of f_hat are identically zero.</p>
<p>Similarly the inverse transform maps the double vector f_hat that is zero except for f_hat(kx-1) = 1.0</p>
<p>to the <a class="el" href="class_s_c_c_1_1_grid_function1d.html">GridFunction1d</a> instance whose ith value is given by</p>
<p>s(i) = sqrt(2.0/LX)*sin(kx*pi*(x_i-xMin)/LX)</p>
<p>with x_i = xMin + i/nx and i = 0,1,...,nx</p>
<p>This class provides forward and inverse sin transforms of two dimensional data stored in <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instances or data stored in <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a> instances. Normalization and scaling is performed so that the transforms computed are close analogs to the mathematical sin transforms of functions defined over intervals of size LX x LY.</p>
<p>The transforms are implemented using the r2r_2d(...) routines from the FFTW3 Fast Fourier Transform library (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). The FFTW3 headers and library files must be available to create any executable that uses this class.</p>
<p>This transform interface is designed be used with the data values of discrete functions with homogeneous boundary values associated with a uniform grid discretization consisting of nx grid panels by ny grid panels spanning a domain of size LX x LY.</p>
<p>When <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a>'s are used for input and/or output their size is (nx-1) x (ny-1); the number of interior data values associated with such discretizations.</p>
<p>For consistency with other FFTW_InterfaceNd classes, in the construction or initialization of class instances, the number of panels nx and ny of a discretization is specified.</p>
<p>For computational efficiency nx and ny should be chosen to be a product of small primes less than or equal to 13 (if possible). </p><hr/>
<p>What's computed assuming the input data is specified as a <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instance initialized with the parameters (nx, xMin, xMax, ny, yMin, yMax):</p>
<p>If (kx,ky) is a wave number vector with kx, and ky in the ranges</p>
<p>1 &lt;= kx &lt;= (nx-1) and 1 &lt;= ky &lt;= (ny-1)</p>
<p>then a <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instance with values given by</p>
<p>d = sqrt(2/LX)*sin(kx*pi*(x_i-xMin)/LX) sqrt(2/LY)*sin(ky*pi*(y_j-yMin)/LY)</p>
<p>evaluated the points</p>
<p>x_i = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y_j = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny</p>
<p>is mapped by the forward transform to a <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a> of size (nx-1)x*(ny-1), f_hat, where</p>
<p>f_hat(kx-1, ky-1) = 1</p>
<p>and all other values are zero.</p>
<p>Similarly the inverse transform maps the <a class="el" href="class_s_c_c_1_1_double_vector2d.html">DoubleVector2d</a> of size (nx-1)x*(ny-1), f_hat, that is zero value except for a value of 1 in (kx-1,ky-1) place to the <a class="el" href="class_s_c_c_1_1_grid_function2d.html">GridFunction2d</a> instance with values corresponding to</p>
<p>d = sqrt(2/LX)*sin(kx*pi*(x_i-xMin)/LX) sqrt(2/LY)*sin(ky*pi*(y_j-yMin)/LY)</p>
<p>evaluated the points</p>
<p>x = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny</p>
<p>After computing the transform of the data, one often wants to work with the discrete Fourier coefficients. Typically this is done by looping over the wave numbers, and then obtaining the coefficient by computing the correct offset. For example, one uses code constructs as indicated by the fragment below.</p>
<p>Loop over sin wave numbers</p>
<pre class="fragment">for(long kx = 1; kx &lt;= nx-1; kx++)
{
for(long ky = 1; ky &lt;= ny-1; ky++)
{
    sCoeff  = f_hat(kx-1,ky-1);  // (kx,ky)'th  sin coefficient is
                                 // the (kx-1,ky-1) entry of the transform


}}</pre><p>This class provides forward and inverse sin transforms of three dimensional data stored in <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instances or data stored in <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a> instances. Normalization and scaling is performed so that the transforms computed are close analogs to the mathematical sin transforms of functions defined over intervals of size LX x LY x LZ.</p>
<p>The transforms are implemented using the r2r_3d(...) routines from the FFTW3 Fast Fourier Transform library (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). The FFTW3 headers and library files must be available to create any executable that uses this class.</p>
<p>This transform interface is designed be used with the data values of discrete functions with homogeneous boundary values associated with a uniform grid discretization consisting of nx grid panels by ny grid panels by nx grid panels spanning a domain of size LX x LY x LZ.</p>
<p>When <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a>'s are used for input and/or output their size is (nx-1) x (ny-1) x (nz-1); the number of interior data values associated with such discretizations.</p>
<p>For consistency with other FFTW_InterfaceNd classes, in the construction or initialization of class instances, the number of panels nx, ny and nz of a discretization is specified.</p>
<p>For computational efficiency nx, ny and nz should be chosen to be a product of small primes less than or equal to 13 (if possible). </p><hr/>
<p>What's computed assuming the input data is specified as a <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instance initialized with the parameters (nx, xMin, xMax, ny, yMin, yMax, nz, zMin, zMax):</p>
<p>If (kx,ky,kz) is a wave number vector with kx, ky, kz in the ranges</p>
<p>1 &lt;= kx &lt;= (nx-1) , 1 &lt;= ky &lt;= (ny-1) and 1 &lt;= kz &lt;= (nz-1)</p>
<p>then a <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instance whose values consist of</p>
<p>d = sqrt(2/LX)*sin(kx*pi*(x_i-xMin)/LX) sqrt(2/LY)*sin(ky*pi*(y_j-yMin)/LY) sqrt(2/LZ)*sin(ky*pi*(z_k-zMin)/LZ)</p>
<p>evaluated the points</p>
<p>x_i = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y_j = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny z_k = zMin + k*hz, k = 0,1,...,nz-1, hz = LZ/nz</p>
<p>gets mapped by the forward transform to a <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a> of size (nx-1)x*(ny-1)x(nz-1), f_hat, where</p>
<p>f_hat(kx-1, ky-1, kz-1) = 1</p>
<p>and all other values are zero.</p>
<p>Similarly the inverse transform maps the <a class="el" href="class_s_c_c_1_1_double_vector3d.html">DoubleVector3d</a> of size (nx-1)x*(ny-1)x(nz-1), f_hat, that is zero value except for a value of 1 in (kx-1,ky-1,kz-1) place to the <a class="el" href="class_s_c_c_1_1_grid_function3d.html">GridFunction3d</a> instance with values corresponding to</p>
<p>d = sqrt(2/LX)*sin(kx*pi*(x_i-xMin)/LX) sqrt(2/LY)*sin(ky*pi*(y_j-yMin)/LY) sqrt(2/LZ)*sin(ky*pi*(z_k-zMin)/LZ)</p>
<p>evaluated the points</p>
<p>x_i = xMin + i*hx, i = 0,1,...,nx-1, hx = LX/nx y_j = yMin + j*hy, j = 0,1,...,ny-1, hy = LY/ny z_k = zMin + k*hz, k = 0,1,...,nz-1, hz = LZ/nz</p>
<p>After computing the transform of the data, one often wants to work with the discrete Fourier coefficients. Typically this is done by looping over the wave numbers, and then obtaining the coefficient by computing the correct offset. For example, one uses code constructs as indicated by the fragment below.</p>
<p>Loop over sin wave numbers</p>
<pre class="fragment">for(long kx = 1; kx &lt;= nx-1; kx++)
{
for(long ky = 1; ky &lt;= ny-1; ky++)
{
for(long kz = 1; kz &lt;= nz-1; kz++)
{
    sCoeff  = f_hat(kx-1,ky-1,kz-1);  // (kx,ky,kz)'th  sin coefficient is
                                      // the (kx-1,ky-1,kz-1) entry of the transform


}}}</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 28 2019 17:24:22 for 270C_Support by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
